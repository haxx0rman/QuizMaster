#!/usr/bin/env python3
"""
Interactive Study Session Script

This script provides a        print("Instructions:")
        print("â€¢ Read each question carefully")
        print("â€¢ Type the number (1-4) of your answer choice")
        print("â€¢ Type 'skip' to skip a question")
        print("â€¢ Type 'save' to save progress without ending session")
        print("â€¢ Type 'quit' to end the session")
        print("â€¢ You'll get immediate feedback after each answer")
        print("â€¢ Progress is automatically saved when you quit")
        print("="*60)active quiz experience using qbank files
generated by test.py. It loads a qbank and allows users to take a
study session with immediate feedback and progress tracking.
"""

import sys
import time
import random
from pathlib import Path
from typing import Dict, Any, List, Optional

# Add the project root to the path so we can import quizmaster modules
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

# Import qBank components if available
try:
    from qbank import QuestionBankManager, StudySession
    QBANK_AVAILABLE = True
except ImportError:
    QBANK_AVAILABLE = False
    print("âš ï¸  qBank not available. Install with: uv add 'qbank @ git+https://github.com/haxx0rman/qBank.git'")
    QuestionBankManager = None
    StudySession = None


class InteractiveStudySession:
    """Interactive study session manager."""
    
    def __init__(self, qbank_file: Path):
        """Initialize the study session with a qbank file."""
        self.qbank_file = qbank_file
        self.manager = None
        self.current_session = None
        self.session_stats = {
            'questions_answered': 0,
            'correct_answers': 0,
            'incorrect_answers': 0,
            'start_time': None,
            'end_time': None,
            'question_times': []
        }
        
        if QBANK_AVAILABLE:
            self._load_qbank()
    
    def _load_qbank(self) -> bool:
        """Load the qbank from file."""
        try:
            # Create a temporary QuestionBankManager
            if QuestionBankManager is not None:
                self.manager = QuestionBankManager(
                    bank_name="Interactive Study Session",
                    user_id="interactive_user"
                )
            else:
                return False
            
            # Import the bank from the JSON file
            self.manager.import_bank(str(self.qbank_file))
            print(f"âœ… Successfully loaded qbank from {self.qbank_file}")
            
            # Get basic stats
            stats = self.manager.get_user_statistics()
            total_questions = stats.get('total_questions', 0)
            print(f"ğŸ“Š Bank contains {total_questions} questions")
            
            return True
            
        except Exception as e:
            print(f"âŒ Failed to load qbank: {e}")
            return False
    
    def display_welcome(self):
        """Display welcome message and instructions."""
        print("\n" + "="*60)
        print("ğŸ“ INTERACTIVE STUDY SESSION")
        print("="*60)
        print("Welcome to your personalized quiz session!")
        print("\nInstructions:")
        print("â€¢ Read each question carefully")
        print("â€¢ Type the number (1-4) of your answer choice")
        print("â€¢ Type 'skip' to skip a question")
        print("â€¢ Type 'quit' to end the session")
        print("â€¢ You'll get immediate feedback after each answer")
        print("="*60)
    
    def display_question(self, question: Any, question_num: int, total_questions: int) -> None:
        """Display a question with its answer choices."""
        print(f"\nğŸ“ Question {question_num} of {total_questions}")
        print("-" * 50)
        print(f"Q: {question.question_text}")
        print()
        
        # Shuffle answers for variety
        answers = list(question.answers)
        random.shuffle(answers)
        
        print("Answer choices:")
        for i, answer in enumerate(answers, 1):
            print(f"  {i}. {answer.text}")
        
        # Store the shuffled answers for later reference
        self._current_answers = answers
        print()
    
    def get_user_input(self) -> Optional[str]:
        """Get and validate user input."""
        while True:
            try:
                user_input = input("Your answer (1-4, 'skip', 'save', or 'quit'): ").strip().lower()
                
                if user_input in ['quit', 'q']:
                    return 'quit'
                elif user_input in ['skip', 's']:
                    return 'skip'
                elif user_input in ['save']:
                    return 'save'
                elif user_input in ['1', '2', '3', '4']:
                    return user_input
                else:
                    print("âŒ Invalid input. Please enter 1-4, 'skip', 'save', or 'quit'.")
                    continue
                    
            except KeyboardInterrupt:
                print("\n\nğŸ‘‹ Session interrupted by user.")
                return 'quit'
            except EOFError:
                print("\n\nğŸ‘‹ Session ended.")
                return 'quit'
    
    def process_answer(self, question: Any, user_choice: str, response_time: float) -> Dict[str, Any]:
        """Process the user's answer and provide feedback."""
        if user_choice == 'skip':
            if self.manager:
                self.manager.skip_question(question.id)
            print("â­ï¸  Question skipped!")
            return {'skipped': True}
        
        # Get the selected answer
        choice_index = int(user_choice) - 1
        selected_answer = self._current_answers[choice_index]
        
        # Submit answer to qbank if available
        result = {'correct': selected_answer.is_correct}
        if self.manager:
            try:
                result = self.manager.answer_question(
                    question_id=question.id,
                    selected_answer_id=selected_answer.id,
                    response_time=response_time
                )
            except Exception as e:
                print(f"âš ï¸  Could not submit to qbank: {e}")
        
        # Update local stats
        self.session_stats['questions_answered'] += 1
        self.session_stats['question_times'].append(response_time)
        
        if result['correct']:
            self.session_stats['correct_answers'] += 1
            print("âœ… Correct!")
        else:
            self.session_stats['incorrect_answers'] += 1
            print("âŒ Incorrect!")
            
            # Find and show the correct answer
            correct_answer = next((a for a in question.answers if a.is_correct), None)
            if correct_answer:
                print(f"ğŸ’¡ The correct answer was: {correct_answer.text}")
        
        # Show explanation if available
        if selected_answer.explanation:
            print(f"ğŸ“– Explanation: {selected_answer.explanation}")
        elif result['correct']:
            # Try to find explanation from correct answer
            correct_answer = next((a for a in question.answers if a.is_correct), None)
            if correct_answer and correct_answer.explanation:
                print(f"ğŸ“– Explanation: {correct_answer.explanation}")
        
        # Show question tags and topic
        if hasattr(question, 'tags') and question.tags:
            print(f"ğŸ·ï¸  Tags: {', '.join(question.tags)}")
        if hasattr(question, 'objective') and question.objective:
            print(f"ğŸ¯ Topic: {question.objective}")
            
        print(f"â±ï¸  Response time: {response_time:.1f} seconds")
        
        return result
    
    def display_progress(self):
        """Display current session progress."""
        total = self.session_stats['questions_answered']
        if total == 0:
            return
            
        correct = self.session_stats['correct_answers']
        accuracy = (correct / total) * 100
        
        print(f"\nğŸ“Š Current Progress: {correct}/{total} correct ({accuracy:.1f}%)")
    
    def start_study_session(self, max_questions: int = 10, tags: Optional[List[str]] = None):
        """Start the interactive study session."""
        if not QBANK_AVAILABLE or not self.manager:
            print("âŒ Cannot start study session - qbank not available")
            return
        
        self.display_welcome()
        
        # Start the session
        self.session_stats['start_time'] = time.time()
        
        try:
            # Get questions for the session
            print(f"\nğŸš€ Starting session with up to {max_questions} questions...")
            if tags:
                print(f"ğŸ·ï¸  Filtering by tags: {', '.join(tags)}")
            
            questions = self.manager.start_study_session(
                max_questions=max_questions,
                tags_filter=set(tags) if tags else None
            )
            
            if not questions:
                print("âŒ No questions available for study session.")
                return
            
            print(f"ğŸ“š Loaded {len(questions)} questions for your session.")
            input("\nPress Enter to begin...")
            
            # Process each question
            for i, question in enumerate(questions, 1):
                print("\n" + "="*60)
                
                # Display question
                self.display_question(question, i, len(questions))
                
                # Get user response
                start_time = time.time()
                user_choice = self.get_user_input()
                response_time = time.time() - start_time
                
                if user_choice == 'quit' or user_choice is None:
                    print("\nğŸ‘‹ Ending session early...")
                    break
                elif user_choice == 'save':
                    self.save_progress()
                    print("Continue with the next question...")
                    continue
                
                # Process the answer
                result = self.process_answer(question, user_choice, response_time)
                
                # Show progress
                if not result.get('skipped'):
                    self.display_progress()
                
                # Pause between questions
                if i < len(questions):
                    input("\nPress Enter for next question...")
            
            # End the session
            self.end_session()
            
        except KeyboardInterrupt:
            print("\n\nâš ï¸  Session interrupted! Saving progress...")
            self.save_progress()
            print("ğŸ‘‹ Session ended.")
        except Exception as e:
            print(f"\nâŒ Error during study session: {e}")
            print("ğŸ’¾ Attempting to save progress...")
            self.save_progress()
            self.end_session()
    
    def end_session(self):
        """End the study session and show final results."""
        self.session_stats['end_time'] = time.time()
        
        # End qbank session if available
        if self.manager:
            try:
                qbank_stats = self.manager.end_study_session()
                if qbank_stats:
                    print("\nğŸ“Š qBank Session Stats:")
                    print(f"   â€¢ Accuracy: {qbank_stats.accuracy:.1f}%")
                    print(f"   â€¢ Questions: {qbank_stats.questions_count}")
                    print(f"   â€¢ Correct: {qbank_stats.correct_count}")
                    print(f"   â€¢ Incorrect: {qbank_stats.incorrect_count}")
            except Exception as e:
                print(f"âš ï¸  Could not get qbank session stats: {e}")
        
        # Save progress back to qbank file
        self.save_progress()
        
        # Display final results
        self.display_final_results()
    
    def save_progress(self):
        """Save the qbank progress back to the original file."""
        if self.manager:
            try:
                print("\nğŸ’¾ Saving progress to qbank file...")
                self.manager.export_bank(str(self.qbank_file))
                print(f"âœ… Progress saved to {self.qbank_file}")
            except Exception as e:
                print(f"âš ï¸  Could not save progress: {e}")
        else:
            print("âš ï¸  No qbank manager available - progress not saved")
    
    def _save_progress(self):
        """Save the updated qbank back to the original file to preserve progress."""
        if not self.manager:
            print("âš ï¸  Cannot save progress - qbank manager not available")
            return
        
        try:
            # Export the updated bank back to the original file
            print(f"\nğŸ’¾ Saving progress to {self.qbank_file}...")
            self.manager.export_bank(str(self.qbank_file))
            print("âœ… Progress saved successfully!")
            
        except Exception as e:
            print(f"âŒ Failed to save progress: {e}")
            
            # Try to save to a backup file
            try:
                backup_file = self.qbank_file.with_suffix('.backup.json')
                self.manager.export_bank(str(backup_file))
                print(f"ğŸ’¾ Progress saved to backup file: {backup_file}")
            except Exception as backup_error:
                print(f"âŒ Failed to save backup: {backup_error}")
    
    def display_final_results(self):
        """Display comprehensive session results."""
        print("\n" + "="*60)
        print("ğŸ‰ SESSION COMPLETE!")
        print("="*60)
        
        total = self.session_stats['questions_answered']
        correct = self.session_stats['correct_answers']
        incorrect = self.session_stats['incorrect_answers']
        
        if total == 0:
            print("No questions were answered.")
            return
        
        accuracy = (correct / total) * 100
        duration = self.session_stats['end_time'] - self.session_stats['start_time']
        
        print("ğŸ“Š Final Results:")
        print(f"   â€¢ Questions Answered: {total}")
        print(f"   â€¢ Correct Answers: {correct}")
        print(f"   â€¢ Incorrect Answers: {incorrect}")
        print(f"   â€¢ Accuracy: {accuracy:.1f}%")
        print(f"   â€¢ Session Duration: {duration:.1f} seconds")
        
        if self.session_stats['question_times']:
            avg_time = sum(self.session_stats['question_times']) / len(self.session_stats['question_times'])
            print(f"   â€¢ Average Response Time: {avg_time:.1f} seconds")
        
        # Performance feedback
        if accuracy >= 90:
            print("\nğŸŒŸ Excellent performance! You've mastered this material!")
        elif accuracy >= 75:
            print("\nğŸ‘ Good job! You have a solid understanding.")
        elif accuracy >= 60:
            print("\nğŸ“š Not bad! Consider reviewing the material and trying again.")
        else:
            print("\nğŸ’ª Keep studying! This material needs more practice.")
        
        print("\nğŸ’¡ Tip: Review incorrect answers and try the session again to improve!")
        print("="*60)


def main():
    """Main function to run the interactive study session."""
    print("ğŸ“ QuizMaster Interactive Study Session")
    print("="*50)
    
    # Default qbank file
    default_qbank = Path("./test_output/qbank_1.json")
    
    # Check if default qbank exists
    if not default_qbank.exists():
        print(f"âŒ Default qbank file not found: {default_qbank}")
        print("ğŸ’¡ Run test.py first to generate a qbank file.")
        
        # Ask user for custom path
        custom_path = input("Enter path to qbank file (or press Enter to exit): ").strip()
        if not custom_path:
            return 1
        
        default_qbank = Path(custom_path)
        if not default_qbank.exists():
            print(f"âŒ Qbank file not found: {default_qbank}")
            return 1
    
    # Create study session
    session = InteractiveStudySession(default_qbank)
    
    if not QBANK_AVAILABLE:
        print("\nâŒ Cannot run interactive session - qBank library not available")
        print("Install with: uv add 'qbank @ git+https://github.com/haxx0rman/qBank.git'")
        return 1
    
    # Get session preferences
    print(f"\nğŸ“ Using qbank: {default_qbank}")
    
    try:
        max_questions = input("How many questions would you like? (default: 10): ").strip()
        max_questions = int(max_questions) if max_questions else 10
        
        tags_input = input("Filter by tags? (comma-separated, or press Enter for all): ").strip()
        tags = [tag.strip() for tag in tags_input.split(",")] if tags_input else None
        
        # Start the session
        session.start_study_session(max_questions=max_questions, tags=tags)
        
    except ValueError:
        print("âŒ Invalid number of questions. Using default: 10")
        session.start_study_session(max_questions=10)
    except KeyboardInterrupt:
        print("\n\nğŸ‘‹ Session cancelled by user.")
        return 1
    
    return 0


if __name__ == "__main__":
    exit(main())
